(function () {
  const config = { startOnLoad: true, theme: "default" };

  function initialize(options) {
    if (options && typeof options === "object") {
      Object.assign(config, options);
    }
    if (config.startOnLoad) {
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", run);
      } else {
        run();
      }
    }
  }

  function parseGraph(text) {
    const nodes = new Map();
    const edges = [];
    const lines = text
      .split("\n")
      .map((line) => line.trim())
      .filter((line) => line.length > 0);

    for (const line of lines) {
      if (line.startsWith("graph")) {
        continue;
      }
      const nodeMatch = line.match(/^([A-Za-z0-9_]+)\\[\"(.*)\"\\]$/);
      if (nodeMatch) {
        nodes.set(nodeMatch[1], nodeMatch[2]);
        continue;
      }
      const edgeMatch = line.match(/^([A-Za-z0-9_]+)\\s*-->\\s*([A-Za-z0-9_]+)/);
      if (edgeMatch) {
        const source = edgeMatch[1];
        const target = edgeMatch[2];
        if (!nodes.has(source)) nodes.set(source, source);
        if (!nodes.has(target)) nodes.set(target, target);
        edges.push([source, target]);
      }
    }
    return { nodes, edges };
  }

  function renderGraph(container, graph) {
    const nodeIds = Array.from(graph.nodes.keys());
    const labels = nodeIds.map((id) => graph.nodes.get(id) || id);
    const maxLabel = labels.reduce((acc, label) => Math.max(acc, label.length), 0);
    const paddingX = 16;
    const nodeHeight = 32;
    const gap = 18;
    const width = Math.max(200, maxLabel * 8 + paddingX * 2);
    const height = nodeIds.length * (nodeHeight + gap) + gap;

    const theme = config.theme === "dark"
      ? {
          bg: "#0f172a",
          node: "#111827",
          stroke: "#1f2937",
          text: "#e2e8f0",
          edge: "#94a3b8",
        }
      : {
          bg: "#f8fafc",
          node: "#ffffff",
          stroke: "#e2e8f0",
          text: "#0f172a",
          edge: "#64748b",
        };

    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, "svg");
    svg.setAttribute("width", String(width + 40));
    svg.setAttribute("height", String(height));
    svg.style.background = theme.bg;
    svg.style.borderRadius = "12px";

    const positions = new Map();
    nodeIds.forEach((id, idx) => {
      const x = 20;
      const y = gap + idx * (nodeHeight + gap);
      positions.set(id, { x, y });

      const rect = document.createElementNS(svgNS, "rect");
      rect.setAttribute("x", String(x));
      rect.setAttribute("y", String(y));
      rect.setAttribute("width", String(width));
      rect.setAttribute("height", String(nodeHeight));
      rect.setAttribute("rx", "8");
      rect.setAttribute("fill", theme.node);
      rect.setAttribute("stroke", theme.stroke);
      rect.setAttribute("stroke-width", "1");
      svg.appendChild(rect);

      const text = document.createElementNS(svgNS, "text");
      text.setAttribute("x", String(x + paddingX));
      text.setAttribute("y", String(y + nodeHeight / 2 + 5));
      text.setAttribute("fill", theme.text);
      text.setAttribute("font-size", "12");
      text.textContent = labels[idx];
      svg.appendChild(text);
    });

    graph.edges.forEach(([source, target]) => {
      const srcPos = positions.get(source);
      const tgtPos = positions.get(target);
      if (!srcPos || !tgtPos) return;
      const x = srcPos.x + width / 2;
      const y1 = srcPos.y + nodeHeight;
      const y2 = tgtPos.y;
      const line = document.createElementNS(svgNS, "line");
      line.setAttribute("x1", String(x));
      line.setAttribute("y1", String(y1));
      line.setAttribute("x2", String(x));
      line.setAttribute("y2", String(y2));
      line.setAttribute("stroke", theme.edge);
      line.setAttribute("stroke-width", "1");
      svg.appendChild(line);
    });

    container.innerHTML = "";
    container.appendChild(svg);
  }

  function run() {
    const elements = document.querySelectorAll(".mermaid");
    elements.forEach((el) => {
      const text = el.textContent || "";
      const graph = parseGraph(text);
      renderGraph(el, graph);
    });
  }

  window.mermaid = {
    initialize,
    run,
  };
})();
