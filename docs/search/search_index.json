{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Nestipy is a Python framework inspired by NestJS and built on top of FastAPI or Blacksheep. It adheres to NestJS's modular architecture, offering a structured approach to developing APIs that's intuitive and enjoyable. With Nestipy, developers can create scalable and maintainable APIs effortlessly. The framework embraces key features like dependency injection, type annotations, decorators, and code generation, facilitating the creation of clean and testable codebases. Notably, Nestipy extends its functionality to support GraphQL through integration with Strawberry. This allows developers to harness the power and flexibility of GraphQL within the Nestipy framework.</p>"},{"location":"#installation","title":"Installation","text":"<p>To get started, you can either scaffold the project with the Nestipy CLI.</p> <pre><code>\npip install nestipy-cli\nnestipy new project-name</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>In this documentation, we solely highlight the distinctions between Nestipy and  NestJS. However, you can refer to the NestJS documentation   for all concepts.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please feel free to submit a Pull Request.</p>"},{"location":"#credits","title":"Credits","text":"<p>NestJS, a framework for building efficient, scalable Node.js server-side applications.</p> <p>FastAPI, a modern, fast (high-performance), web framework for building APIs with Python.</p> <p>Blacksheep, an asynchronous web framework to build event-based web applications with Python.</p> <p>Strawberry, a developer friendly GraphQL library for Python, designed for modern development.</p>"},{"location":"cli/","title":"Cli","text":"<p>List of available command for Nestipy-CLI :</p> <ul> <li> new {project-name}</li> <li> generate (g, gen)     <ul> <li>resource (r, res) {resource-name}</li> <li>module (mod) {module-name}</li> <li>controller (ctrl) {controller-name}</li> <li>resolver {resolver-name}</li> <li>service {service-name}</li> <li>input {input-name}</li> </ul> </li> </ul>"},{"location":"dynamic/","title":"Dynamic","text":""},{"location":"dynamic/#nice-to-know","title":"Nice to know","text":"<ol> <li>[x] A dynamic module must be decorated with <code>@Module()</code> and must extends <code>DynamicModule</code></li> <li>[x] Inside Dynamic module, we can access ioc container by <code>self.get_container()</code> and this container , inside property <code>instances</code> we can access to any instance of ModuleProvider or Service that we have declared in any Module.</li> <li>[x] <code>on_startup</code>, and <code>on_shutdown</code> hooks are available in any Module(Dynamic or Not)</li> <li>[x] We can define a provider by using <code>ModuleProvider</code> instance instead of create a service in Module.</li> <li>[x] All provider declared in <code>AppModule</code> are declared as Global Provider</li> <li>[x] Module is is compiled by its priority order of declaration in imports</li> </ol>"},{"location":"gateway/","title":"Gateway","text":""},{"location":"gateway/#using-socketio-gateway","title":"Using socketIO Gateway","text":"<ol> <li>[x] First create gateway provider  <code>nestipy g provider EventGateway</code> <code>event_gateway.py</code> <pre><code>from nestipy.common import Gateway, GATEWAY_SERVER, SubscribeMessage\nfrom socketio import AsyncServer\n\n@Gateway()\nclass EventGateway:\n    server: AsyncServer = Inject(GATEWAY_SERVER)\n\n    SubscribeMessage('message')\n    def on_message(self, sid, data):\n        print(sid, data)\n        self.server.emit('message', data, sid)</code></pre></li> <li>[x] Register EventGateway in app_module providers</li> <li>[x] Modify <code>main.py</code> by adding:  <pre><code>import socketio \n...\nsio = socketio.AsyncServer(async_mode='asgi')\napp.useSocketIo(sio)\n...</code></pre> 4.[x] Everything will be ok </li> <li>[x] When socketIo in register in main, GATEWAY_SERVER provider will be available every where by injecting it.</li> </ol>"},{"location":"plugin/","title":"Plugin","text":""},{"location":"plugin/#list-of-available-modules","title":"List of available modules","text":""},{"location":"plugin/#strawberry-module","title":"Strawberry module","text":"<p>Usage: register Strawberry module in <code>app_module.py</code> to use it  <code>app_module.py</code></p> <pre><code>...\nfrom nestipy.plugins.strawberry_module.strawberry_module import StrawberryModule, StrawberryOption\n\n...\n\n\n@Module(\n    imports=[\n        ...\n        StrawberryModule.for_root(\n            resolvers=[UserModule],\n            option=StrawberryOption(graphql_ide='graphiql')\n        ),\n        ...\n    ],\n)\nclass AppModule:\n    pass</code></pre> <p>In resolvers import all modules that you have defined your resolvers.</p>"},{"location":"plugin/#config-module","title":"Config module","text":"<p>Usage: register Config module in <code>app_module.py</code> to use it  <code>app_module.py</code></p> <p><pre><code>...\nfrom nestipy.plugins.config_module.config_module import ConfigModule\n...\n\n\n@Module(\n    imports=[\n        ...\n        ConfigModule.for_root(),\n        ...\n    ],\n\n)\nclass AppModule(NestipyModule):\n   pass\n</code></pre> <code>ConfigModule.for_root()</code> can receive a parameter of .env file</p> <p><code>ConfigModule</code> is a global module, so <code>ConfigService</code> can be injected in any Controller, Resolver, or Service. You can use method <code>get('key')</code> of <code>ConfigService</code> to get value by key from your <code>.env</code> file.</p>"},{"location":"plugin/#peewee-module","title":"Peewee module","text":"<p>Usage: register Peewee module in <code>app_module.py</code> to use it  </p> <p><code>app_module.py</code></p> <p><pre><code>...\nfrom nestipy.plugins.peewee_module.peewee_module import PeeweeModule,PeeweeDatabaseConfig\nfrom nestipy.plugins.config_module.config_module import ConfigModule, ConfigService\n...\n\n\nasync def peewee_mysql_factory(config: ConfigService) -&gt; PeeweeDatabaseConfig:\n    return PeeweeDatabaseConfig(\n        driver='mysql',\n        database=config.get(\"DB_DATABASE\"),\n        host=config.get(\"DB_HOST\"),\n        port=int(f'{config.get(\"DB_PORT\")}'),\n        user=config.get(\"DB_USER\"),\n        password=config.get(\"DB_PASSWORD\") or ''\n    )\n\n@Module(\n    imports=[\n        ...\n        ConfigModule.for_root(),\n         PeeweeModule.for_root_async(\n            use_factory=peewee_mysql_factory,\n            inject=[ConfigService]\n        ),\n        ...\n    ],\n\n)\nclass AppModule(NestipyModule):\n   pass\n</code></pre> In this example, we show the dependency between module. So , in this case, <code>ConfigModule</code> must be registered in top of <code>PeeweeModule</code>.  <code>ConfigService</code> is a provider exported by <code>ConfigModule</code></p> <p>To register a model in peewee, model must decorate with <code>@Model</code> from <code>peewee_module</code> and must be register by calling <code>PeeweeModule.for_feature([MyModel])</code> in imports of Module. </p>"},{"location":"plugin/#masonite-orm-module","title":"Masonite orm module","text":"<p>Usage: register Masonite orm module in <code>app_module.py</code> to use it  </p> <p><code>app_module.py</code></p> <pre><code>...\nfrom nestipy.plugins.masonite_orm_module.masonite_orm_module import MasoniteOrmModule, MasoniteDatabaseConfig\n...\nasync def masonite_factory(config: ConfigService):\n    await asyncio.sleep(0.4)\n    return {\n        'default': 'mysql',\n        'mysql': MasoniteDatabaseConfig(\n            driver='mysql',\n            host=config.get(\"DB_HOST\"),\n            port=config.get(\"DB_PORT\"),\n            user=config.get(\"DB_USER\"),\n            password=config.get(\"DB_PASSWORD\") or '',\n            database=config.get(\"DB_DATABASE\")\n        )\n    }\n@Module(\n    imports=[\n        ...,\n        ConfigModule.for_root(),\n        MasoniteOrmModule.for_root_async(\n            factory=masonite_factory,\n            inject=[ConfigService]\n        ),\n        ...\n    ]\n)\nclass AppModule:\n    pass</code></pre>"},{"location":"plugin/#beanie-mongo-module","title":"Beanie mongo module","text":"<p>Usage: register Beanie mongo module in <code>app_module.py</code> to use it  </p> <p><code>app_module.py</code></p> <p><pre><code>..\nfrom nestipy.plugins.beanie_module.beanie_module import BeanieModule\n...\n\nasync def beanie_factory(config: ConfigService):\n    return config.get('MONGODB_URL')\n\n\n@Module(\n    imports=[\n        ...,\n        ConfigModule.for_root(),\n        BeanieModule.for_root_async(\n            use_factory=beanie_factory,\n            inject=[ConfigService],\n            documents= [\n                #Register document here or use BeanieModule.for_feature([MyDocument])\n            ]\n        ),\n        ...\n    ]\n)\nclass AppModule:\n    pass</code></pre> You must call <code>BeanieModule.for_feature([MyDocument])</code> inside module imports to register a document.</p>"},{"location":"start/","title":"Get started with Nestipy","text":""},{"location":"start/#introduction","title":"Introduction","text":"<p>This documentation introduces a creation of the simplest Nestipy Application.</p>"},{"location":"start/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10+</li> <li>Nestipy (latest version)</li> </ul>"},{"location":"start/#example","title":"Example","text":""},{"location":"start/#github","title":"Github","text":"<p>Navigate on Nestipy example</p>"},{"location":"start/#setting-up","title":"Setting Up","text":""},{"location":"start/#installation-and-setup","title":"Installation and Setup","text":"<p>All you need to getting started is to install only nestipy, you can achieve this by running the following command using pip</p> <pre><code>pip install nestipy</code></pre>"},{"location":"start/#start-with-cli","title":"Start with cli","text":""},{"location":"start/#create-a-new-project","title":"Create a new project","text":"<pre><code>nestipy new my_app</code></pre> <p>This command will create a new project with the following structure:</p> <pre><code>\u251c\u2500\u2500 app_module.py\n\u251c\u2500\u2500 app_controller.py\n\u251c\u2500\u2500 app_service.py\n\u251c\u2500\u2500 main.py\n|\u2500\u2500 requirements.txt\n|\u2500\u2500 README.md\n\u251c\u2500\u2500 src\n\u2502    \u251c\u2500\u2500 __init__.py</code></pre> <p>After creating the project, to start serve, run the following command inside the project directory:</p> <pre><code>python main.py</code></pre> <p>Now you can access the application at http://localhost:8000/schema/swagger for Litestar, http://localhost:8000/docs for Fastapi and test the endpoints.</p> <p>Let's go over the boilerplate code that generated by the cli:</p> <pre><code>from nestipy.common.decorator import Module\nfrom .app_controller import AppController\nfrom .app_service import AppService\n\n\n@Module(\n    controllers=[AppController],\n    providers=[AppService]\n)\nclass AppModule:\n    pass\n</code></pre> <p><code>app_controller.py</code></p> <pre><code>from nestipy.common.decorator import Controller, Get, Inject, Post, Put, Delete\nfrom .app_service import AppService\n\n\n@Controller()\nclass AppController:\n    service: AppService = Inject(AppService)\n\n    @Get()\n    async def get(self) -&gt; str:\n        return await self.service.get()\n\n    @Post()\n    async def post(self, data: str) -&gt; str:\n        return await self.service.post(data=data)\n\n    @Put('/{user_id}')\n    async def put(self, user_id: int, data: str) -&gt; str:\n        return await self.service.put(id_=user_id, data=data)\n\n    @Delete('/{user_id}')\n    async def delete(self, user_id: int) -&gt; None:\n        await self.service.delete(id_=user_id)\n</code></pre> <p><code>app_service.py</code></p> <pre><code>from nestipy.common.decorator import Injectable\n\n\n@Injectable()\nclass AppService:\n\n    @classmethod\n    async def get(cls):\n        return \"test\"\n\n    @classmethod\n    async def post(cls, data: str):\n        return \"test\"\n\n    @classmethod\n    async def put(cls, id_: int, data: str):\n        return \"test\"\n\n    @classmethod\n    async def delete(cls, id_: int):\n        return \"test\"\n</code></pre> <p><code>main.py</code></p> <pre><code>import uvicorn\n\nfrom .app_module import AppModule\nfrom nestipy.core.factory import NestipyFactory\n# from nestipy.core.platform import PlatformFastAPI\n\nfrom nestipy.core.platform import PlatformLitestar\n\n# app = NestipyFactory[PlatformFastAPI].create(AppModule, title=\"My FastAPI App\")\napp = NestipyFactory[PlatformLitestar].create(AppModule, title=\"My App\")\n\nif __name__ == '__main__':\n    uvicorn.run('main:app', host=\"0.0.0.0\", port=8000, reload=True)\n\n</code></pre>"},{"location":"start/#creating-new-resource","title":"Creating new resource","text":"<p>After creating the project, let's create a new resource:</p> <pre><code>pynest g resource user\n-&gt; api\n-&gt; graphql</code></pre> <p>By choosing api, we have generated new folder inside src</p> <pre><code>\u251c\u2500\u2500 user\n\u2502    \u251c\u2500\u2500 __init__.py\n\u2502    \u251c\u2500\u2500 user_controller.py\n\u2502    \u251c\u2500\u2500 user_service.py\n\u2502    \u251c\u2500\u2500 user_dto.py\n\u2502    \u251c\u2500\u2500 user_module.py</code></pre> <p>By choosing graphql, we have resolver instead of controller, like the following</p> <pre><code>\u251c\u2500\u2500 user\n\u2502    \u251c\u2500\u2500 __init__.py\n\u2502    \u251c\u2500\u2500 user_resolver.py\n\u2502    \u251c\u2500\u2500 user_service.py\n\u2502    \u251c\u2500\u2500 user_input.py\n\u2502    \u251c\u2500\u2500 user_module.py</code></pre> <p>By using graphql, dont forget to register strawberry module from nestipy plugin inside app_module imports.</p> <pre><code>...\nfrom nestipy.plugins.strawberry_module.strawberry_module import StrawberryModule, StrawberryOption\n\n...\n\n\n@Module(\n    imports=[\n        ...\n        StrawberryModule.for_root(\n            resolvers=[UserModule],\n            option=StrawberryOption(graphql_ide='graphiql')\n        ),\n        ...\n    ],\n)\nclass AppModule:\n    pass</code></pre>"},{"location":"start/#creating-new-module","title":"Creating new module","text":"<p>With nestipy we can create a module by running the following command</p> <pre><code>nestipy g module example</code></pre> <p>This command will create a new directory example inside src and update app_module imports to import this new module.</p> <pre><code>\u251c\u2500\u2500 example\n\u2502    \u251c\u2500\u2500 __init__.py\n\u2502    \u251c\u2500\u2500 example_module.py</code></pre> <p>So inside, we got,</p> <p><code>example_module.py</code></p> <pre><code>from nestipy.common.decorator import Module\nfrom nestipy.common.decorator import Module\n\n\n@Module()\nclass ExampleModule:\n    pass</code></pre>"},{"location":"start/#creating-new-controller","title":"Creating new controller","text":"<p>Create a controller to handle the requests and responses.</p> <pre><code>nestipy g controller example</code></pre> <p><code>examples_controller.py</code></p> <pre><code>\nfrom nestipy.common.decorator import Controller, Get\n\n\n@Controller('examples')\nclass ExampleController:\n\n    @Get()\n    async def get(self) -&gt; str:\n        return \"test\"\n</code></pre>"},{"location":"start/#creating-new-resolver","title":"Creating new resolver","text":"<p>Or for graphql , create a resolver.</p> <pre><code>nestipy g resolver example</code></pre> <p><code>examples_resolver.py</code></p> <pre><code>\nfrom strawberry.types import Info\nfrom nestipy.plugins.strawberry_module.decorator import Resolver, Query, Mutation\n\n\n@Resolver()\nclass ExampleResolver:\n\n    @Query()\n    def example_test_query(self, root: Info) -&gt; str:\n        return \"test\"\n\n    @Mutation()\n    def example_test_mutation(self, root: Info, test: str) -&gt; str:\n        return test\n\n</code></pre>"},{"location":"start/#creating-new-service","title":"Creating new service","text":"<p>Implement services to handle business logic.</p> <pre><code>nestipy g service example</code></pre> <p><code>examples_service.py</code></p> <pre><code>from nestipy.common.decorator import Injectable\n\n\n@Injectable()\nclass ExampleService:\n\n    async def test(self):\n        pass\n</code></pre> <p>Service is injectable inside a controller, resolver or other service by using Inject to inject it as a property of them.</p> <pre><code>service: ExampleService = Inject(ExampleService)</code></pre>"},{"location":"util/","title":"Utils","text":""},{"location":"util/#config-static-dir-based-view-lifecycle-hook-cors","title":"Config static dir, based view, lifecycle hook, cors","text":"<pre><code>import os\n\nfrom nestipy.core import NestipyFactory\nfrom nestipy.common import session\n\napp = NestipyFactory.create(AppModule)\n\n# Enable cors\napp.enable_cors()\n\n# define static folder\napp.use_static_assets(os.path.join(os.path.dirname(__file__), 'public'))\n\n# Config view for template rendering\napp.set_base_view_dir(os.path.join(os.path.dirname(__file__), 'views'))\napp.set_view_engine('minijinja')  # minijinja as template engine.\n\ntemplate_engine = app.get_template_engine()  # get template engine\n\n# use session\napp.use(session())\n\n# LIFECYCLE HOOKS \n\n@app.on_startup\nasync def on_startup_callback():\n    print('Starting ...')\n\n\n@app.on_shutdown\nasync def on_shutdown_callback():\n    print('Shutdown ...')</code></pre> <p>Render template</p> <pre><code>from nestipy.common import Get, Response, Request, Render\nfrom nestipy.types_ import Req, Res\n\n\nclass AppController:\n\n    @Render('index.html')\n    @Get()\n    async def test(self, req: Req[Request], res: Res[Response]):\n        return {'title': 'Hello'}\n        # return await res.render('index.html', {'title': 'Hello'})</code></pre>"},{"location":"fundamental/custom-provider/","title":"Custom providers","text":"<p>We will learn to have same way how NestJs create and use providers.</p>"},{"location":"fundamental/custom-provider/#standard-providers","title":"Standard providers","text":"<pre><code>@Module(\n    controllers=[CatsController],\n    providers=[CatsService],\n)</code></pre>"},{"location":"fundamental/custom-provider/#value-providers","title":"Value providers","text":"<pre><code>from nestipy.common import ModuleProviderDict\n\n\n@Module(\n    controllers=[CatsController],\n    providers=[\n        ModuleProviderDict(\n            token=CatsService,\n            value=CatsService\n        )\n    ],\n)</code></pre>"},{"location":"fundamental/custom-provider/#non-class-based-provider-tokens","title":"Non-class-based provider tokens","text":"<pre><code>\nfrom nestipy.common import Module, ModuleProviderDict\nfrom .connection import connection\n\n\n@Module(\n    controllers=[CatsController],\n    providers=[\n        ModuleProviderDict(\n            token='CONNECTION',\n            value=connection\n        )\n    ],\n)\nclass AppModule:\n    pass</code></pre> <p>For, use_class and use_existing, it's the same as NestJs.</p>"},{"location":"fundamental/custom-provider/#factory-provider","title":"Factory provider","text":"<pre><code>\nfrom nestipy.common import ModuleProviderDict, Module\nfrom .connection import connection\n\n\ndef factory_value() -&gt; str:\n    return connection\n\n\n@Module(\n    controllers=[CatsController],\n    providers=[\n        ModuleProviderDict(\n            token='CONNECTION',\n            factory=factory_value\n        )\n    ],\n)\nclass AppModule:\n    pass\n</code></pre> <p>Factory can be an async function to have async provider.</p>"},{"location":"fundamental/custom-provider/#inject-providers","title":"Inject providers","text":"<pre><code>from nestipy.common.decorator import Controller\nfrom nestipy.ioc import Inject\n\n\n@Controller('cats')\nclass CatsController:\n    connection: Inject['CONNECTION']\n    cat_service: Inject[CatsService]</code></pre> <p>Exporting non-class based provider works perfectly.</p>"},{"location":"fundamental/dynamic-module/","title":"Dynamic modules","text":"<p>Let's start directly with and example. We are going to create <code>ConfigModule</code> like <code>ConfigModule</code> from NestJs.</p> <pre><code>from dataclasses import dataclass\nfrom os import path, getcwd\nfrom typing import Union\n\nfrom dotenv import dotenv_values\nfrom nestipy.common import Module, Injectable\nfrom nestipy.dynamic_module import ConfigurableModuleBuilder\nfrom nestipy.ioc import Inject\n\n\n@dataclass\nclass ConfigOption:\n    dir: str = getcwd()\n\n\nConfigurableModuleClass, MODULE_OPTION_TOKEN = ConfigurableModuleBuilder[ConfigOption]().build()\n\n\n@Injectable()\nclass ConfigService:\n    _config: Inject[MODULE_OPTION_TOKEN]\n    _envs: dict = {}\n\n    def __init__(self):\n        file = path.join(self._config.dir, '.env')\n        _envs: dict = dotenv_values(file)\n\n    def get(self, key: str) -&gt; Union[str, None]:\n        if key in self._envs.keys():\n            return self._envs.get(key)\n        return None\n\n\n@Module(\n    providers=[ConfigService],\n    exports=[ConfigService]\n)\nclass ConfigModule(ConfigurableModuleClass):\n    pass</code></pre> <p>So, let's view how to use it.</p> <pre><code>from nestipy.common import Module\n\n\n@Module(\n    imports=[\n        ConfigModule.register()  # we can define ConfigOption in register\n        # ConfigModule.register(options=ConfigOption(dir=getcwd()))\n    ],\n    ...\n)\nclass AppModule:\n    pass</code></pre> <p>Now, we can use <code>ConfigModule</code> in controller or a service provider by injecting it.</p> <pre><code>from nestipy.ioc import Inject\n\nfrom nestipy.common import Controller\n\n\n@Controller('cats')\nclass CatsController:\n    config_service: Inject[ConfigService]</code></pre> <p>Inside service,</p> <pre><code>from nestipy.common import Injectable\nfrom nestipy.types_ import Inject\n\n\n@Injectable()\nclass CatsService:\n    config_service: Inject[ConfigService]</code></pre> <p>Using it inside async factory.</p> <pre><code>from dataclasses import dataclass\n\nfrom nestipy.dynamic_module import ConfigurableModuleBuilder, NestipyModule\nfrom nestipy.ioc import Inject\n\nfrom nestipy.common import ConfigModule, ConfigService\nfrom nestipy.common import Module\n\n\n@dataclass\nclass DatabaseConfigOption:\n    host: str\n    password: str\n    user: str\n    port: int = 3306\n\n\nConfigurableModuleClass, MODULE_OPTION_TOKEN = ConfigurableModuleBuilder[DatabaseConfigOption]().set_method(\n    'for_root').build()\n\n\n@Module()\nclass DatabaseModule(ConfigurableModuleClass, NestipyModule):\n    option: Inject[MODULE_OPTION_TOKEN]\n\n    def on_startup(self):\n        # start connection to database by using option\n        pass\n\n    def on_shutdown(self):\n        # stop connection to database\n        pass\n\n\nasync def database_config_factory(config: ConfigService) -&gt; DatabaseConfigOption:\n    return DatabaseConfigOption(\n        host=config.get('DB_HOST'),\n        port=int(config.get('DB_PORT')),\n        password=config.get('DB_PASSWORD'),\n        user=config.get('DB_USER')\n    )\n\n\n@Module(\n    imports=[\n        ConfigModule.register(),\n        DatabaseModule.for_root_async(\n            factory=database_config_factory,\n            inject=[ConfigService]\n        )\n    ]\n)\nclass AppModule:\n    pass</code></pre> <p>Note: We can inject service directly inside <code>Module</code> if we want to use <code>DatabaseService</code> with lifecycle hook inside `DatabaseModule</p> <p>Take a look here for an  example.</p>"},{"location":"fundamental/testing/","title":"Testing","text":"<p>Coming soon</p>"},{"location":"graphql/quick-start/","title":"Quick start","text":"<p>Currently, Nestipy uses Strawberry as its GraphQL ASGI. It's compatible with Guards, Interceptor and ExceptionFilter . Nestipy simplifies the syntax to operate more like NestJS does with GraphQL.</p>"},{"location":"graphql/quick-start/#configuration","title":"Configuration","text":"<p>To use GraphQL wit Nestipy, we need to add <code>GraphQlModule</code> in root module <code>AppModule</code>.</p> <pre><code>from nestipy.common import Module\nfrom nestipy.graphql import GraphqlModule, GraphqlOption\n\n\n@Module(\n    imports=[\n        ...\n        GraphqlModule.for_root(options=GraphqlOption())\n        ...\n    ],\n    providers=[\n        CatsResolver\n    ]\n\n)\nclass AppModule:\n    pass</code></pre> <p>So, <code>CatsResolver</code> will be like.</p> <pre><code>import asyncio\nfrom typing import AsyncIterator\n\nfrom nestipy.graphql import Resolver, Query, Mutation, Subscription\nfrom nestipy.types_ import Args\n\n\n@Resolver()\nclass CatsResolver:\n    @Query()\n    @UseGuards(TestGuardMethod)\n    def test_query(self, test: Args[str]) -&gt; str:\n        return \"Query\"\n\n    @Mutation()\n    def test_mutation(self) -&gt; str:\n        return 'Mutation'\n\n    @Subscription()\n    async def test_subscription(self, count: Args[int] = 1000) -&gt; AsyncIterator[int]:\n        for i in range(count):\n            yield i\n            await asyncio.sleep(0.5)</code></pre> <p>For scalar, input, etc.. we can reef to Strawberry documentation  and using alias from</p> <pre><code>from nestipy.graphql.strawberry import ObjectType, Input, Field, Interface, Scalar, SchemaDirective, etc\n\n...\n\n...</code></pre> <p>Or use its from Strawberry's definition.</p> <pre><code>from strawberry import type, input, interface, scalar, etc\n\n...\n\n...</code></pre> <p>Take a look here for an example.</p>"},{"location":"openapi/start/","title":"Openapi","text":"<p>Nestipy use openapi_docs.v3 cloned from  Blacksheep openapidocs. It's available via <code>from nestipy.openapi.openapi_docs.v3 import Parameter</code>.</p> <p>Let's view how it works.</p> <pre><code>\nimport dataclasses\n\n# from nestipy.openapi.openapi_docs.v3 import Parameter\nfrom nestipy.common import Controller, Post, Get, Render\nfrom nestipy.common import HttpException, HttpStatusMessages, HttpStatus\nfrom nestipy.common import Request, Response\nfrom nestipy.ioc import Req, Res, Body\nfrom nestipy.openapi import ApiTags, ApiOkResponse, ApiNotFoundResponse, ApiCreatedResponse, ApiBearerAuth, ApiBody\n\n\n@dataclasses.dataclass\nclass TestBody:\n    test: str\n\n\n@Controller()\n@ApiTags('App')\n@ApiOkResponse()\n@ApiNotFoundResponse()\nclass AppController:\n\n    @Render('index.html')\n    @Get()\n    async def test(self, req: Req[Request], res: Res[Response]):\n        return {'title': 'Hello'}\n        # return await res.render('index.html', {'title': 'Hello'})\n\n    @Post()\n    @ApiBody(TestBody)\n    # @ApiBody(TestBody, 'application/json')\n    @ApiBearerAuth()  # Enable security bearer\n    @ApiCreatedResponse()\n    async def post(self, res: Res[Response], body: Body[TestBody]):\n        raise HttpException(HttpStatus.UNAUTHORIZED, HttpStatusMessages.UNAUTHORIZED)</code></pre>"},{"location":"openapi/start/#swagger","title":"Swagger","text":"<p>This is how config swagger with Nestipy.</p> <pre><code>from nestipy.core.nestipy_factory import NestipyFactory\nfrom nestipy.core.platform import NestipyFastApiApplication\nfrom nestipy.openapi import DocumentBuilder, SwaggerModule\n\napp = NestipyFactory[NestipyFastApiApplication].create(AppModule)\n\n# setup swagger\ndocument = DocumentBuilder().set_title('Example API').set_description('The API description').set_version(\n    '1.0').add_bearer_auth().add_basic_auth().build()\nSwaggerModule.setup('api', app, document)</code></pre> <p>Now, we can access localhost:8000/api to show swagger documentation.</p>"},{"location":"overview/controller/","title":"Controllers","text":"<p>Controller in Nestipy look like</p> <pre><code>from nestipy.common import Controller, Get\n\n\n@Controller('cats')\nclass CatsController:\n    @Get()\n    async def findAll(self) -&gt; str:\n        return 'This action returns all cats'\n</code></pre>"},{"location":"overview/controller/#request-and-response-object","title":"Request and Response object","text":"<p>We can access Request and Response object from handler bu using annotation type Req and Res respectively.</p> <pre><code>from nestipy.ioc import Req, Res\n\nfrom nestipy.common import Controller, Get, Response, Request\n\n\n@Controller('cats')\nclass CatsController:\n    @Get()\n    async def findAll(self, req: Req[Request], res: Res[Response]) -&gt; str:\n        return await res.send('This action returns all cats')\n</code></pre>"},{"location":"overview/controller/#full-resource-sample","title":"Full resource sample","text":"<p>Below is a sample illustrating how different decorators are employed to create a basic controller. This controller furnishes methods for accessing and modifying internal data.</p> <pre><code>from dataclasses import dataclass\n\nfrom nestipy.common import Controller, Get, Put, Post, Delete\nfrom nestipy.ioc import Body, Query, Param, Session, Headers\n\n\n@dataclass\nclass CreateCat:\n    name: str\n\n\n@Controller('cats')\nclass CatsController:\n\n    @Post()\n    async def create(self, data: Body[CreateCat]) -&gt; str:\n        return 'This action adds a new cat'\n\n    @Get()\n    async def find_all(self, limit: Query[int], headers: Headers[dict]) -&gt; str:\n        return f\"This action returns all cats (limit: {limit} items\"\n\n    @Get('/{cat_id}')\n    async def find_one(self, cat_id: Param[str]):\n        return f\"This action returns a #{cat_id} cat\"\n\n    @Put('/{cat_id}')\n    async def update(self, cat_id: Param[str], data: Body[CreateCat]):\n        return f\"This action updates a #{cat_id} cat\"\n\n    @Delete('/{cat_id}')\n    async def remove(self, cat_id: Param[str], user_id: Session[int, None]):\n        return f\"This action removes a #{cat_id} cat\"\n\n\n</code></pre>"},{"location":"overview/controller/#getting-up-and-running","title":"Getting up and running","text":"<p>Similar to NestJs, registering controllers within modules is required.</p> <p><pre><code>from nestipy.common import Module\nfrom .cats_controller import CatsController\n\n\n@Module(\n    controllers=[\n        CatsController\n    ]\n)\nclass AppModule:\n    pass</code></pre> Take a look here for an  example. </p>"},{"location":"overview/exception-filter/","title":"Exceptions filters","text":"<p>This is a example of using exception filter with Nestipy.</p> <pre><code>from typing import Any\n\nfrom nestipy.common import ExceptionFilter, Catch, HttpException\nfrom nestipy.core import ArgumentHost\n\n\n@Catch()\nclass HttpExceptionFilter(ExceptionFilter):\n    async def catch(self, exception: HttpException, host: ArgumentHost) -&gt; Any:\n        print('Catcher')</code></pre> <p>To catch specific exception we need to create class that extends <code>HttpException</code>.</p> <pre><code>import datetime\nfrom typing import Any\n\nfrom nestipy.common import ExceptionFilter, Catch, HttpStatus, HttpStatusMessages, HttpException,\nfrom nestipy.core import ArgumentHost\n\n\nclass BadRequestException(HttpException):\n    def __init__(self):\n        super(self, ).__init__(HttpStatus.BAD_REQUEST, HttpStatusMessages.BAD_REQUEST)\n\n\n@Catch(BadRequestException)\nclass BadRequestExceptionFilter(ExceptionFilter):\n    async def catch(self, exception: HttpException, host: ArgumentHost) -&gt; Any:\n        response = host.get_response()\n        request = host.get_request()\n        status = exception.status_code\n        print('Catcher')\n        return await response.json({\n            'statusCode': status,\n            'timestamp': datetime.datetime.now().strftime(\"%d/%m/%Y, %H:%M:%S\"),\n            'path': request.path,\n        })\n</code></pre>"},{"location":"overview/exception-filter/#binding-filters","title":"Binding filters","text":"<p>Let's tie our new BadRequestExceptionFilter to the CatsController's create() method.</p> <pre><code>from nestipy.common import Controller, Post\nfrom nestipy.common import UseFilters\n\n\n@Controller('cats')\nclass CatsController:\n\n    @UseFilters(BadRequestExceptionFilter)\n    @Post()\n    async def create(self):\n        raise BadRequestException()</code></pre> <p>Apply on controller.</p> <pre><code>from nestipy.common import Controller, Post\nfrom nestipy.common import UseFilters\n\n\n@UseFilters(BadRequestExceptionFilter)\n@Controller('cats')\nclass CatsController:\n\n    @Post()\n    async def create(self):\n        raise BadRequestException()</code></pre> <p>To create a global-scoped filter, you would do the following:</p> <pre><code>from nestipy.core.nestipy_factory import NestipyFactory\n\napp = NestipyFactory.create(AppModule)\n\napp.use_global_filters(BadRequestExceptionFilter)</code></pre> <p>Using it from provider.</p> <p><pre><code>\n\nfrom nestipy.common import Module, ModuleProviderDict\nfrom nestipy.core.constant import AppKey\n\n\n@Module(\n    providers=[\n        ModuleProviderDict(token=AppKey.APP_FILTER, use_class=BadRequestExceptionFilter)\n    ]\n)\nclass AppModule:\n\n\n</code></pre> Take a look here for an  example.</p>"},{"location":"overview/first-step/","title":"First steps","text":"<p>These articles will teach you the basic principles of Nestipy. You'll get to know its key components by building a simple CRUD application, which will introduce you to various beginner-level features.</p>"},{"location":"overview/first-step/#prerequisites","title":"Prerequisites","text":"<p>Please make sure that Python (version &gt;= 3.9) is installed on your operating system.</p>"},{"location":"overview/first-step/#setup","title":"Setup","text":"<p>Starting a fresh project using the Nestipy CLI is simple. Just configure Python's environment and run these commands in your OS terminal to create a new Nestipy project. <pre><code>\npip install nestipy-cli\nnestipy new project-name</code></pre> Upon execution, a directory named <code>project-name</code> will be generated, containing a src/ directory filled with essential core files.</p> <pre><code>\u251c\u2500\u2500 app_module.py\n\u251c\u2500\u2500 app_controller.py\n\u251c\u2500\u2500 app_service.py\n\u251c\u2500\u2500 main.py\n|\u2500\u2500 requirements.txt\n|\u2500\u2500 README.md\n\u251c\u2500\u2500 src\n\u2502    \u251c\u2500\u2500 __init__.py</code></pre> <p>The main.py file contains an instance of application and bootstrapping it with uvicorn.</p> <pre><code>import uvicorn\nfrom nestipy.core import NestipyFactory\n\nfrom app_module import AppModule\n\napp = NestipyFactory.create(AppModule)\n\nif __name__ == '__main__':\n    uvicorn.run('main:app', reload=True)</code></pre>"},{"location":"overview/first-step/#platform","title":"Platform","text":"<p>In essence, Nestipy can function with any ASGI framework once an adapter is developed. It inherently supports two ASGI platforms: FastAPI and BlackSheep. You have the freedom to select the one that aligns most closely with your requirements. By default, Nestipy use FastAPI adapter.  We can specify platform from NestipyFactory. <pre><code>from nestipy.core import NestipyFastApiApplication\n\napp = NestipyFactory[NestipyFastApiApplication].create(AppModule)\n</code></pre> Or with blacksheep</p> <pre><code>from nestipy.core import NestipyBlackSheepApplication\n\napp = NestipyFactory[NestipyBlackSheepApplication].create(AppModule)</code></pre>"},{"location":"overview/first-step/#running-the-application","title":"Running the application","text":"<p>After installation, simply run this command in your OS terminal to start the application and listen for incoming HTTP requests:</p> <p><pre><code>python main.py</code></pre> Take a look here for an  example.</p> <p></p>"},{"location":"overview/guard/","title":"Guards","text":"<p>A guard is a class annotated with the <code>@Injectable()</code> decorator, which implements the <code>CanActivate</code> interface.</p>"},{"location":"overview/guard/#authorization-guard","title":"Authorization guard","text":"<pre><code>from typing import Awaitable, Union\n\nfrom nestipy.common import CanActivate\nfrom nestipy.common import Injectable\nfrom nestipy.core import ExecutionContext\n\n\n@Injectable()\nclass AuthGuard(CanActivate):\n    def can_activate(self, context: ExecutionContext) -&gt; Union[Awaitable[bool], bool]:\n        req = context.switch_to_http().get_request()\n        return req.headers.get('Authorization') is not None\n</code></pre>"},{"location":"overview/guard/#binding-guards","title":"Binding guards","text":"<p>Guard can bing like with four ways, in controller, method, global and in provider.</p> <pre><code>from nestipy.common import Controller, Post, UseGuards\n\n\n@UseGuards(AuthGuard)\n@Controller('cats')\nclass CatsController:\n\n    @UseGuards(AuthGuard)\n    @Post()\n    async def create(self):\n        pass</code></pre> <p>Use guard globally by provider</p> <pre><code>from nestipy.common import Module, ModuleProviderDict\nfrom nestipy.core import AppKey\n\n\n@Module(\n    providers=[\n        ModuleProviderDict(\n            AppKey.APP_GUARD,\n            use_class=AuthGuard\n        )\n    ]\n)\nclass AppModule:\n    pass</code></pre> <p>Or use guard globally in <code>main.py</code></p> <pre><code>from nestipy.core import NestipyFactory\n\napp = NestipyFactory.create(AppModule)\napp.use_global_guards(AuthGuard)\n</code></pre>"},{"location":"overview/guard/#full-example-for-roles-guard","title":"Full example for roles guard","text":"<pre><code>import typing\nfrom typing import Union, Awaitable\n\nfrom nestipy.metadata import SetMetadata, Reflect\n\nfrom nestipy.common import CanActivate, UseGuards\nfrom nestipy.common import Controller, Post, Injectable\nfrom nestipy.core import ExecutionContext\n\nROLES = 'ROLES'\n\n\ndef Roles(roles: list[str]):\n    return SetMetadata(ROLES, roles, as_list=True)\n\n\n@Injectable()\nclass RolesGuard(CanActivate):\n    async def can_activate(self, context: ExecutionContext) -&gt; Union[Awaitable[bool], bool]:\n        handler = context.get_handler()\n        class_handler = context.get_class()\n        req = context.switch_to_http().get_request()\n        roles = list(set(Reflect.get_metadata(class_handler, ROLES, []) + Reflect.get_metadata(handler, ROLES, [])))\n        user_roles = req.user.roles if req.user is not None else []\n        return len(set(typing.cast(list[str], user_roles)) &amp; set(roles)) &gt; 0\n\n\n@UseGuards(RolesGuard)\n@Controller('cats')\nclass CatsController:\n    @Post()\n    @Roles(['admin'])\n    async def create(self):\n        pass</code></pre> <p>Take a look here for an  example.</p>"},{"location":"overview/interceptor/","title":"Interceptors","text":"<p>In simpler terms, Nestipy offers Interceptor functionality, which functions similarly to how Interceptors work in NestJs, allowing you to intercept requests. Nestipy Interceptor must be a class that extends <code>NestipyInterceptor</code>.</p> <pre><code>from nestipy.common import Injectable\nfrom nestipy.common import NestipyInterceptor\nfrom nestipy.core import ExecutionContext\nfrom nestipy.types_ import NextFn\n\n\n@Injectable()\nclass TestInterceptor(NestipyInterceptor):\n    async def intercept(self, context: ExecutionContext, next_fn: NextFn):\n        print('Intercepted...')\n        return await next_fn()</code></pre>"},{"location":"overview/interceptor/#apply-interceptors","title":"Apply interceptors","text":"<p>Interceptors can be applied to controllers, specific controller methods, within modules via providers, or even globally across the application.</p> <pre><code>\n\nfrom nestipy.common import Controller, Post, UseInterceptors, Module, ModuleProviderDict\nfrom nestipy.core import AppKey\n\n\n@UseInterceptors(TestInterceptor)\n@Controller('cats')\nclass CatsController:\n\n    @UseInterceptors(TestInterceptor)\n    @Post()\n    async def create(self):\n        pass\n\n\n@Module(\n    controllers=[\n        CatsController\n    ],\n    providers=[\n        ModuleProviderDict(token=AppKey.APP_INTERCEPTOR, use_class=TestInterceptor)\n    ]\n)\nclass AppModule:\n    pass\n</code></pre> <p>Globally , it works like.</p> <p><pre><code>from nestipy.core import NestipyFactory\n\napp = NestipyFactory.create(AppModule)\napp.use_global_interceptors(TestInterceptor)</code></pre> Take a look here for an  example.</p>"},{"location":"overview/middleware/","title":"Middlewares","text":"<p>Nestipy define middleware like NestJs do.</p> <pre><code>from nestipy.common import Injectable\n\nfrom nestipy.common import Request, Response\nfrom nestipy.common import NestipyMiddleware\nfrom nestipy.types_ import NextFn\n\n\n@Injectable()\nclass LoggerMiddleware(NestipyMiddleware):\n    async def use(self, req: Request, res: Response, next_fn: NextFn):\n        print('Requesting ....')\n        await next_fn()</code></pre>"},{"location":"overview/middleware/#dependency-injection","title":"Dependency injection","text":"<p>Nestipy middleware support dependency injection</p>"},{"location":"overview/middleware/#applying-middleware","title":"Applying middleware","text":"<p>Nestipy apply middleware like the way Nestjs use. Modules that include middleware have to implement the NestipyModule.</p> <pre><code>from nestipy.dynamic_module import NestipyModule\n\nfrom nestipy.common import Module\nfrom nestipy.core import MiddlewareConsumer\n\n\n@Module()\nclass AppModule(NestipyModule):\n    def configure(self, consumer: MiddlewareConsumer):\n        consumer.apply(LoggerMiddleware).for_route('cats')\n</code></pre>"},{"location":"overview/middleware/#apply-middleware-for-controller","title":"Apply middleware for controller","text":"<p>We can apply middleware for controller and excludes some routes.</p> <pre><code>from nestipy.dynamic_module import NestipyModule\n\nfrom nestipy.common import Module\nfrom nestipy.core import MiddlewareConsumer\n\n\n@Module()\nclass AppModule(NestipyModule):\n    def configure(self, consumer: MiddlewareConsumer):\n        consumer.apply(LoggerMiddleware).for_route(CatsController).excludes([])\n</code></pre>"},{"location":"overview/middleware/#functional-middleware","title":"Functional middleware","text":"<pre><code>from nestipy.common import Request, Response\nfrom nestipy.types_ import NextFn\n\n\nasync def logger(req: Request, res: Response, next_fn: NextFn):\n    print('Requesting ....')\n    await next_fn()</code></pre> <p>And use it within the AppModule:</p> <pre><code>consumer.apply(logger).for_route(CatsController).excludes([])</code></pre>"},{"location":"overview/middleware/#global-middleware","title":"Global middleware","text":"<pre><code>from nestipy.core import NestipyFactory\n\napp = NestipyFactory.create(AppModule)\napp.use(logger)</code></pre> <p>Take a look here for an  example.</p>"},{"location":"overview/module/","title":"Modules","text":"<p>For Nestipy, module works like NestJs module . It support re-exporting as same as NestJs.</p>"},{"location":"overview/module/#dynamic-modules","title":"Dynamic modules","text":"<p>Following is an example of a dynamic module definition for a <code>DatabaseModule</code>:</p> <pre><code>from nestipy.common import Module\nfrom nestipy.dynamic_module import DynamicModule\n\n\n@Module()\nclass DatabaseModule:\n    @classmethod\n    def register(cls) -&gt; DynamicModule:\n        return DynamicModule(\n            module=cls,\n            providers=[],\n            controllers=[],\n            imports=[],\n            exports=[]\n        )</code></pre> <p>If we want to use params from <code>@Module()</code> decorator in dynamic module, we must do like the following example.</p> <pre><code>from dataclasses import dataclass\n\nfrom nestipy.dynamic_module import DynamicModule\nfrom nestipy.ioc import Inject\nfrom nestipy.metadata import Reflect, ModuleMetadata\n\nfrom nestipy.common import Module, ModuleProviderDict, Injectable\n\n\n@dataclass\nclass DatabaseOption:\n    option: str = ''\n\n\nDATABASE_OPTION = 'DATABASE_OPTION'\n\n\n@Injectable()\nclass DatabaseService:\n    option: Inject[DATABASE_OPTION]\n\n\n@Module(\n    is_global=True,\n    providers=[DatabaseService]\n)\nclass DatabaseModule:\n    # this will be an instance of DatabaseOption \n\n    @classmethod\n    def register(cls, option: DatabaseOption) -&gt; DynamicModule:\n        return DynamicModule(\n            module=cls,\n            providers=[ModuleProviderDict(token=DATABASE_OPTION, value=option)] + Reflect.get_metadata(\n                cls,\n                ModuleMetadata.Providers,\n                []\n            ),\n            controllers=[] + Reflect.get_metadata(cls, ModuleMetadata.Controllers, []),\n            imports=[] + Reflect.get_metadata(cls, ModuleMetadata.Imports, []),\n            exports=[] + Reflect.get_metadata(cls, ModuleMetadata.Exports, []),\n            is_global=Reflect.get_metadata(cls, ModuleMetadata.Global, False)\n        )</code></pre> <p>To facilitate creating of Dynamic module, Nestipy provide <code>ConfigurableModuleBuilder</code> class rom <code>nestipy.dynamic_module</code>.</p> <p>This is an example.</p> <pre><code>from dataclasses import dataclass\n\nfrom nestipy.dynamic_module import ConfigurableModuleBuilder\nfrom nestipy.ioc import Inject\n\n\n@dataclass\nclass DatabaseOption:\n    option: str = ''\n\n\nConfigurableModuleClass, DATABASE_MODULE_OPTION_TOKEN = ConfigurableModuleBuilder[DatabaseOption]().set_method(\n    'for_root').build()\n\n\nclass DatabaseModule(ConfigurableModuleClass):\n    option: Inject[DATABASE_MODULE_OPTION_TOKEN]\n</code></pre> <p>For this, we will call <code>DatabaseModule.for_root(option)</code> or <code>DatabaseModule.for_root_async(option_async)</code> to register Module. The default method to call is <code>register</code> and <code>register_async</code> if it's not defined.</p> <p>For a lifecycle hooks, we need to extends <code>NestipyModule</code>.</p> <pre><code>from dataclasses import dataclass\n\nfrom nestipy.dynamic_module import ConfigurableModuleBuilder\nfrom nestipy.dynamic_module import NestipyModule\nfrom nestipy.ioc import Inject\n\n\n@dataclass\nclass DatabaseOption:\n    option: str = ''\n\n\nConfigurableModuleClass, DATABASE_MODULE_OPTION_TOKEN = ConfigurableModuleBuilder[DatabaseOption]().set_method(\n    'for_root').build()\n\n\nclass DatabaseModule(ConfigurableModuleClass, NestipyModule):\n    option: Inject[DATABASE_MODULE_OPTION_TOKEN]\n\n    async def on_startup(self):\n        pass\n\n    async def on_shutdown(self):\n        pass\n\n</code></pre> <p> </p>"},{"location":"overview/provider/","title":"Providers","text":"<p>Provider is the same for NestJs providers.</p>"},{"location":"overview/provider/#services","title":"Services","text":"<p>Let's create a example of service.</p> <pre><code>from typing import Any\n\nfrom nestipy.common import Injectable\n\n\n@Injectable()\nclass CatsService:\n    _cats: list[Any] = []\n\n    def create(self, cat: Any):\n        self._cats.append(cat)\n\n    def find_all(self):\n        return self._cats</code></pre> <p>This is how we use it inside controller.</p> <pre><code>\nfrom dataclasses import dataclass\n\nfrom nestipy.ioc import Inject, Body\n\nfrom nestipy.common import Controller, Post, Get\nfrom .cats_service import CatsService\n\n\n@dataclass\nclass CreateCat:\n    name: str\n\n\n@Controller('cats')\nclass CatsController:\n    _service: Inject[CatsService]\n\n    @Post()\n    async def create(self, data: Body[CreateCat]):\n        self._service.create(data)\n\n    @Get()\n    async def find_all(self):\n        return self._service.find_all()</code></pre> <p>Register provider in module.</p> <pre><code>\nfrom nestipy.common import Module\n\n\n@Module(\n    providers=[\n        CatsService\n    ],\n    controllers=[\n        CatsController\n    ]\n)\nclass CatsModule:\n    pass</code></pre> <p>Provider can be exported to use by other module.</p> <pre><code>\nfrom nestipy.common import Module\n\n\n@Module(\n    providers=[\n        CatsService\n    ],\n    controllers=[\n        CatsController\n    ],\n    exports=[\n        CatsService\n    ]\n)\nclass CatsModule:\n    pass</code></pre>"},{"location":"overview/provider/#dependency-injection","title":"Dependency injection","text":"<p>With Nestipy, dependency work in 2 ways: </p>"},{"location":"overview/provider/#inject-dependency-via-property-for-class","title":"Inject dependency via property( for class).","text":"<pre><code>@Controller('cats')\nclass CatsController:\n    _service: Inject[CatsService]</code></pre>"},{"location":"overview/provider/#inject-dependency-via-class-method","title":"Inject dependency via class method.","text":"<p>It work like other dependency method.</p> <p>Take a look here for an  example.</p>"},{"location":"websocket/adapter/","title":"Adapters","text":"<p>Coming soon</p>"},{"location":"websocket/gateway/","title":"Gateways","text":"<p>By default, Nestipy use socketio as a Gateway. However, we can create our own adapter.</p> <p>Firstly, we need to create a gateway class</p> <pre><code>\n\nfrom nestipy.ioc import SocketServer, SocketClient, SocketData\n\nfrom nestipy.websocket import IoAdapter, Gateway, SubscribeMessage\n\n\n@Gateway()\nclass AppGateway:\n    server: SocketServer[IoAdapter]\n\n    @SubscribeMessage('user')\n    async def on_user(self, sid: SocketClient[str], data: SocketData[str]):\n        print(sid, data)\n        await self.server.emit('user', data, sid)</code></pre> <p>Now, use gateway as module provider.</p> <pre><code>\nfrom nestipy.common.decorator import Module\n\n\n@Module(\n    providers=[\n        AppGateway\n    ]\n)\nclass AppModule:\n    pass</code></pre> <p>After all, we need to tell Nestipy to use socketio as io adapater.</p> <pre><code>\nimport socketio\n\nfrom nestipy.core.nestipy_factory import NestipyFactory\nfrom nestipy.websocket import SocketIoAdapter\n\napp = NestipyFactory.create(AppModule)\nsio = socketio.AsyncServer(async_mode='asgi')\napp.use_io_adapter(SocketIoAdapter(sio))\n</code></pre> <p>Gateway is marked as Injectable, it means you can inject it into controllers or other services within the same module. You can also inject it everywhere if it's defined as a provider in the root module.</p> <p>A working example can be found here.</p>"}]}